#!/usr/bin/env python3

# MIT License
#
# Copyright (c) [2020 - 2021] Mauro Bringolf and Dominik Winterer
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import time
import signal
import sys
import os
from pathlib import Path
import subprocess
import time
import datetime
import psutil
import random
import atexit

path = Path(__file__)
rootpath = str(path.parent.absolute().parent)
sys.path.append(rootpath)

from fuzzing_configuration import *
from src.reduction.Reducer import RegressionReducer, ImplicationReducer

SOLVERS = [f'{Z3_NEW} | {Z3_OLD}', f'{CVC5_NEW} | {CVC5_OLD}']
OUTPUT_WIDTH = 80
# results from fuzzing
BUG_DIR = './bugs/'
# for temporary files created during reduction
REDUCING_DIR = './reducing/'
REDUCED_DIR = './reduced/'


def pick_random_file(from_dir):
    next_step = subprocess.getoutput(f'/bin/ls -1 {from_dir} | shuf -n1')
    if os.path.isdir(f"{from_dir}/{next_step}"):
        return pick_random_file(f"{from_dir}/{next_step}")
    else:
        return f"{from_dir}/{next_step}"



if __name__ == "__main__":

    start_time = datetime.datetime.now()

    os.system(f"mkdir -p {BUG_DIR}")
    os.system(f"mkdir -p {REDUCING_DIR}")
    os.system(f"mkdir -p {REDUCED_DIR}")

    js = []
    rs = []

    num_additional_output_lines = 0

    """
    def start_new_regression_reducer(old_solver, new_solver, f):
        os.rename(f'bugs/{f}', f'bugs/{f}.orig')
        return subprocess.Popen(
            [
                'timeout',
                TIMEOUT_PER_REDUCER,
                'ddsmt',
                '-j',
                str(NUM_PROCS_PER_REDUCER),
                '-v',
                '--ignore-output',
                f"./bugs/{f}.orig",
                f"./reducing/{f}",
                './bin/check-regression.py',
                str(SOLVER_TIMEOUT),
                old_solver,
                new_solver,
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
        )

    def start_new_implication_reducer(solver, f, rule_name):
        os.rename(f'bugs/{f}', f'bugs/{f}.orig')
        return subprocess.Popen(
            [
                'timeout',
                TIMEOUT_PER_REDUCER,
                'ddsmt',
                '-j',
                str(NUM_PROCS_PER_REDUCER),
                '-v',
                '--ignore-output',
                f"./bugs/{f}.orig",
                f"./reducing/{f}",
                './bin/check-implication.py',
                str(SOLVER_TIMEOUT),
                solver,
                rule_name,
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
        )
    """

    def start_new_instance():

        oracle = None

        while oracle == None:
            seed = pick_random_file(SEED_DIR)
            set_status = subprocess.getoutput(f'grep "(set-info :status .*)" {seed}')
            if '/sat/' in seed or 'sat' in set_status:
                oracle = 'sat'
            elif '/unsat/' in seed or 'unsat' in set_status:
                oracle = 'unsat'

        return subprocess.Popen(
            [
                'timeout',
                TIMEOUT_PER_INSTANCE,
                'bin/janus',
                '-t',
                str(SOLVER_TIMEOUT),
                '-rs',
                RULE_SET,
                '-i',
                str(ITERATIONS),
                '-wl',
                str(WALK_LENGTH),
                '-o',
                oracle,
                ';'.join(SOLVERS),
                seed,
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
        )

    def killall():
        for j in js:
            j.terminate()
        for b, r in rs:
            # Make bug eligible for reduction again by renaming the trigger file back to '.smt2'
            # When the fuzzer is restarted afterwards, the
            r.terminate()
            if os.path.exists(f"./bugs/{b}.orig"):
                os.rename(f"./bugs/{b}.orig", f"./bugs/{b}")
            if os.path.exists(f"./reducing/{b}"):
                os.remove(f"./reducing/{b}")


    def replace_finished():
        for i, j in enumerate(js):
            rc = j.poll()
            if rc is not None:
                js[i] = start_new_instance()
        for i, (f,so,sn,rn,r) in enumerate(rs):
            rc = r.poll()
            if rc is not None:
                os.rename(f"./reducing/{f}", f"./reduced/{f}")
                os.rename(f"./bugs/{f}.orig", f"./reduced/{f}.orig")
                del rs[i]
                reducible_bugs = list(
                    filter(
                        lambda f: f.endswith('.smt2')
                        and (
                            'regression-incompleteness-cvc5' in f
                            or 'regression-incompleteness-z3' in f
                        ),
                        os.listdir('bugs'),
                    )
                )
                if len(reducible_bugs) > 0:
                    bug = reducible_bugs[0]
                    solver_old, solver_new = (
                        (CVC5_OLD, CVC5_NEW)
                        if 'regression-incompleteness-cvc5' in bug
                        else (Z3_OLD, Z3_NEW)
                    )
                    rs.append(
                        (bug, start_new_regression_reducer(solver_old, solver_new, bug))
                    )

        reducible_bugs = list(
            filter(
                lambda f: f.endswith('.smt2')
                and (
                    'regression-incompleteness-cvc5' in f
                    or 'regression-incompleteness-z3' in f
                ),
                os.listdir('bugs'),
            )
        )

        for bug, _ in zip(reducible_bugs, range(len(rs), MAX_NUM_REDUCERS)):
            solver_old, solver_new = (
                (CVC5_OLD, CVC5_NEW)
                if 'regression-incompleteness-cvc5' in bug
                else (Z3_OLD, Z3_NEW)
            )
            rs.append((bug, solver_old, solver_new, None, start_new_regression_reducer(solver_old, solver_new, bug)))

    def print_status():

        cvc5_regressions = 0
        cvc5_implications = 0
        cvc5_unsound = 0
        cvc5_crash = 0
        cvc5_segfault = 0
        z3_regressions = 0
        z3_implications = 0
        z3_unsound = 0
        z3_crash = 0
        z3_segfault = 0

        for f in filter(
            lambda f: f.endswith('.smt2') and not f.endswith('-previous.smt2'),
            os.listdir('bugs'),
        ):
            if 'regression-incompleteness-cvc5' in f:
                cvc5_regressions += 1
            if 'regression-incompleteness-z3' in f:
                z3_regressions += 1
            if 'implication-incompleteness-cvc5' in f:
                cvc5_implications += 1
            if 'implication-incompleteness-z3' in f:
                z3_implications += 1
            if 'incorrect-z3' in f:
                z3_unsound += 1
            if 'incorrect-cvc5' in f:
                cvc5_unsound += 1
            if 'crash-z3' in f:
                z3_crash += 1
            if 'crash-cvc5' in f:
                cvc5_crash += 1
            if 'segfault-z3' in f:
                z3_segfault += 1
            if 'segfault-cvc5' in f:
                cvc5_segfault += 1

        cvc5_regressions_r = 0
        cvc5_implications_r = 0
        z3_regressions_r = 0
        z3_implications_r = 0

        for f in filter(
            lambda f: f.endswith('.smt2') and not f.endswith('-previous.smt2'),
            os.listdir('reduced'),
        ):
            if 'regression-incompleteness-cvc5' in f:
                cvc5_regressions_r += 1
            if 'regression-incompleteness-z3' in f:
                z3_regressions_r += 1
            if 'implication-incompleteness-cvc5' in f:
                cvc5_implications_r += 1
            if 'implication-incompleteness-z3' in f:
                z3_implications_r += 1

        running_j = 0
        for j in js:
            if j.poll() is None:
                running_j += 1
        running_r = 0
        for r in rs:
            if r.is_finished():
                running_r += 1

        num_processes = len(psutil.Process().children())

        status_lines = list(
            map(
                lambda l: l.ljust(OUTPUT_WIDTH),
                [
                    f"started: {start_time.strftime('%d/%m/%Y %H:%M:%S')}",
                    f"uptime: {str(datetime.datetime.now() - start_time).split('.')[0]}",
                    f"number of processes: {num_processes}",
                    f"Running instances: {running_j}/{MAX_NUM_INSTANCES}",
                    f"Running reducers: {running_r}/{MAX_NUM_REDUCERS}",
                    f"Unreduced segfaults: {z3_segfault} (z3), {cvc5_segfault} (cvc5)",
                    f"Unreduced crashes: {z3_crash} (z3), {cvc5_crash} (cvc5)",
                    f"Unreduced unsoundnesses: {z3_unsound} (z3), {cvc5_unsound} (cvc5)",
                    f"Unreduced regressions: {z3_regressions} (z3), {cvc5_regressions} (cvc5)",
                    f"Unreduced implications: {z3_implications} (z3), {cvc5_implications} (cvc5)",
                    f"Reduced regressions: {z3_regressions_r} (z3), {cvc5_regressions_r} (cvc5)",
                    f"Reduced implications: {z3_implications_r} (z3), {cvc5_implications_r} (cvc5)",
                ],
            )
        )
        status = '\n'.join(status_lines) + '\n' + ('=' * OUTPUT_WIDTH) + '\n'
        prevlines = "\033[F" * (status.count('\n') + 1)
        sys.stdout.write(prevlines + '\n' + status)
        sys.stdout.flush()

    def cleanup(signum, frame):
        signal.signal(signum, signal.SIG_IGN)
        killall()
        sys.exit(0)

    signal.signal(signal.SIGINT, cleanup)
    atexit.register(killall)

    for _ in range(MAX_NUM_INSTANCES):
        js.append(start_new_instance())

    for bug in filter(lambda f: f.endswith('.smt2') and not f.endswith('-previous.smt2'), os.listdir('bugs')):
        if len(rs) >= MAX_NUM_REDUCERS:
            break
        if 'regression-incompleteness-z3' in bug:
            reducer = RegressionReducer(bug, Z3_NEW, Z3_OLD)
            reducer.start()
            rs.append(reducer)
            #rs.append((bug, Z3_OLD, Z3_NEW, None, start_new_regression_reducer(Z3_OLD, Z3_NEW, bug)))
        if 'regression-incompleteness-cvc5' in bug:
            reducer = RegressionReducer(bug, CVC5_NEW, CVC5_OLD)
            reducer.start()
            rs.append(reducer)
            #rs.append((bug, CVC5_OLD, CVC5_NEW, None, start_new_regression_reducer(CVC5_OLD, CVC5_NEW, bug)))
        if 'implication-incompleteness-z3' in bug:
            known_file = f"bugs/{bug[:-5]}-previous.smt2"
            rule_file = open(f"bugs/{bug[:-5]}.output", "r")
            rule_name = rule_file.read()
            rule_file.close()
            reducer = ImplicationReducer(bug, Z3_NEW, rule_name)
            reducer.start()
            rs.append(reducer)
            #rs.append((known_file, None, Z3_NEW, rule_name, start_new_implication_reducer(Z3_NEW, known_file, rule_name)))
        if 'implication-incompleteness-cvc5' in bug:
            known_file = f"bugs/{bug[:-5]}-previous.smt2"
            rule_file = open(f"bugs/{bug[:-5]}.output", "r")
            rule_name = rule_file.read()
            rule_file.close()
            reducer = ImplicationReducer(bug, CVC5_NEW, rule_name)
            reducer.start()
            rs.append(reducer)
            #rs.append((known_file, None, CVC5_NEW, rule_name, start_new_implication_reducer(CVC5_NEW, known_file, rule_name)))

    while True:
        print_status()
#        replace_finished()
        time.sleep(5)

    killall()
