#!/usr/bin/env python3

import time
import signal
import sys
import os
import subprocess
import time
import datetime
import psutil
import atexit

Z3_NEW = '/local/home/maurob/impbased-fuzzing-experiments/solvers/z3/build/z3'
Z3_OLD = '/local/home/maurob/impbased-fuzzing-experiments/solvers/z3-4.8.12/build/z3'
CVC5_NEW = '/local/home/maurob/impbased-fuzzing-experiments/solvers/cvc4/build/bin/cvc5 -q --strings-exp'
CVC5_OLD = '/local/home/maurob/impbased-fuzzing-experiments/solvers/cvc4-1.8 -q --strings-exp'

SOLVERS = [f'{Z3_NEW} | {Z3_OLD}', f'{CVC5_NEW} | {CVC5_OLD}']
SEED_DIR = '/local/home/maurob/impbased-fuzzing-experiments/semantic-fusion-seeds/QF_SLIA/sat'
MAX_NUM_INSTANCES = 10
MAX_NUM_REDUCERS = 5
NUM_PROCS_PER_REDUCER = 10
SOLVER_TIMEOUT = 10
ITERATIONS = 300
WALK_LENGTH = 20
TIMEOUT_PER_INSTANCE = f"{str(ITERATIONS*SOLVER_TIMEOUT)}s"
TIMEOUT_PER_REDUCER = '1h'
RULE_SET = 'all'
OUTPUT_WIDTH = 80

if __name__ == "__main__":

    start_time = datetime.datetime.now()
    js = []
    rs = []

    num_additional_output_lines = 0

    def start_new_reducer(old_solver, new_solver, f):
        os.rename(f'./bugs/{f}', f'./bugs/{f}.orig')
        return subprocess.Popen(['timeout', TIMEOUT_PER_REDUCER, 'ddsmt', '-j', str(NUM_PROCS_PER_REDUCER), '-v', '--ignore-output', f"./bugs/{f}.orig", f"./reducing/{f}", './bin/check-regression.py', str(SOLVER_TIMEOUT), old_solver, new_solver], 
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
        )


    def start_new_instance():
        return subprocess.Popen(
            [
                'timeout',
                TIMEOUT_PER_INSTANCE,
                'bin/janus',
                '-t',
                str(SOLVER_TIMEOUT),
                '-rs',
                RULE_SET,
                '-i',
                str(ITERATIONS),
                '-wl',
                str(WALK_LENGTH),
                '-o',
                'sat',
                ';'.join(SOLVERS),
                SEED_DIR,
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
        )

    def killall():
        for j in js:
            j.terminate()
        for b, r in rs:
            r.terminate()

    def replace_finished():
        for i, j in enumerate(js):
            rc = j.poll()
            if rc is not None:
                js[i] = start_new_instance()
        for i, (f, r) in enumerate(rs):
            rc = r.poll()
            if rc is not None:
                os.rename(f"./reducing/{f}", f"./reduced/{f}")
                os.rename(f"./bugs/{f}.orig", f"./reduced/{f}.orig")
                del rs[i]
                reducible_bugs = list(filter(lambda f: f.endswith('.smt2') and ('regression-incompleteness-cvc5' in f or 'regression-incompleteness-z3' in f), os.listdir('bugs')))
                if len(reducible_bugs) > 0:
                    bug = reducible_bugs[0]
                    solver_old, solver_new = (CVC5_OLD,CVC_NEW) if 'regression-incompleteness-cvc5' in bug else (Z3_OLD, Z3_NEW)
                    rs.append((bug, start_new_reducer(solver_old, solver_new, bug)))

        reducible_bugs = list(filter(lambda f: f.endswith('.smt2') and ('regression-incompleteness-cvc5' in f or 'regression-incompleteness-z3' in f), os.listdir('bugs')))

        for bug,_ in zip(reducible_bugs, range(len(rs), MAX_NUM_REDUCERS)):
            solver_old, solver_new = (CVC5_OLD,CVC_NEW) if 'regression-incompleteness-cvc5' in bug else (Z3_OLD, Z3_NEW)
            rs.append((bug, start_new_reducer(solver_old, solver_new, bug)))

    def print_status():
       
        cvc5_regressions = 0
        cvc5_implications = 0
        z3_regressions = 0
        z3_implications = 0

        for f in filter(lambda f: f.endswith('.smt2') and not f.endswith('-previous.smt2'),os.listdir('bugs')):
            if 'regression-incompleteness-cvc5' in f:
                cvc5_regressions += 1
            if 'regression-incompleteness-z3' in f:
                z3_regressions += 1
            if 'implication incompleteness-cvc5' in f:
                cvc5_implications += 1
            if 'implication incompleteness-z3' in f:
                z3_implications += 1

        cvc5_regressions_r = 0
        cvc5_implications_r = 0
        z3_regressions_r = 0
        z3_implications_r = 0

        for f in filter(lambda f: f.endswith('.smt2') and not f.endswith('-previous.smt2'),os.listdir('reduced')):
            if 'regression-incompleteness-cvc5' in f:
                cvc5_regressions_r += 1
            if 'regression-incompleteness-z3' in f:
                z3_regressions_r += 1
            if 'implication incompleteness-cvc5' in f:
                cvc5_implications_r += 1
            if 'implication incompleteness-z3' in f:
                z3_implications_r += 1

        running_j = 0
        for j in js:
            if j.poll() is None:
                running_j += 1
        running_r = 0
        for b, r in rs:
            if r.poll() is None:
                running_r += 1

        num_processes = len(psutil.Process().children())

        status_lines = list(map(lambda l: l.ljust(OUTPUT_WIDTH), [
        f"started: {start_time.strftime('%d/%m/%Y %H:%M:%S')}",
        f"uptime: {str(datetime.datetime.now() - start_time).split('.')[0]}",
        f"number of processes: {num_processes}",
        f"Running instances: {running_j}/{MAX_NUM_INSTANCES}",
        f"Running reducers: {running_r}/{MAX_NUM_REDUCERS}",
        f"Unreduced regressions: {z3_regressions} (z3), {cvc5_regressions} (cvc5)",
        f"Unreduced implications: {z3_implications} (z3), {cvc5_implications} (cvc5)",
        f"Reduced regressions: {z3_regressions_r} (z3), {cvc5_regressions_r} (cvc5)",
        f"Reduced implications: {z3_implications_r} (z3), {cvc5_implications_r} (cvc5)",
        ]))
        status = '\n'.join(status_lines) + '\n' + ('='*OUTPUT_WIDTH) + '\n'
        prevlines = "\033[F" * (status.count('\n') + 1)
        sys.stdout.write(prevlines + '\n' + status)
        sys.stdout.flush()

    def cleanup(signum, frame):
        signal.signal(signum, signal.SIG_IGN)
        killall()
        sys.exit(0)

    signal.signal(signal.SIGINT, cleanup)
    atexit.register(killall)

    for _ in range(MAX_NUM_INSTANCES):
        js.append(start_new_instance())

    for bug in filter(lambda f: f.endswith('.smt2'), os.listdir('bugs')):
        if len(rs) >= MAX_NUM_REDUCERS:
            break
        if 'regression-incompleteness-z3' in bug:
            rs.append((bug, start_new_reducer(Z3_OLD, Z3_NEW, bug)))
        if 'regression-incompleteness-cvc5' in bug:
            rs.append((bug, start_new_reducer(CVC5_OLD, CVC5_NEW, bug)))

    while True:
        print_status()
        replace_finished()
        time.sleep(5)

    killall()
