#!/usr/bin/env python3

import time
import signal
import sys
import os
from pathlib import Path
import subprocess
import time
import datetime
import psutil
import random
import atexit

path = Path(__file__)
rootpath = str(path.parent.absolute().parent)
sys.path.append(rootpath)

from fuzzing_configuration import *

SOLVERS = [f'{Z3_NEW} | {Z3_OLD}', f'{CVC5_NEW} | {CVC5_OLD}']
OUTPUT_WIDTH = 80


def pick_random_file(from_dir):
    next_step = subprocess.getoutput(f'/bin/ls -1 {from_dir} | shuf -n1')
    if os.path.isdir(f"{from_dir}/{next_step}"):
        return pick_random_file(f"{from_dir}/{next_step}")
    else:
        return f"{from_dir}/{next_step}"


if __name__ == "__main__":

    start_time = datetime.datetime.now()
    js = []
    rs = []

    num_additional_output_lines = 0

    def start_new_reducer(old_solver, new_solver, f):
        os.rename(f'./bugs/{f}', f'./bugs/{f}.orig')
        return subprocess.Popen(
            [
                'timeout',
                TIMEOUT_PER_REDUCER,
                'ddsmt',
                '-j',
                str(NUM_PROCS_PER_REDUCER),
                '-v',
                '--ignore-output',
                f"./bugs/{f}.orig",
                f"./reducing/{f}",
                './bin/check-regression.py',
                str(SOLVER_TIMEOUT),
                old_solver,
                new_solver,
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
        )

    def start_new_instance():

        oracle = None

        while oracle == None:
            seed = pick_random_file(SEED_DIR)
            set_status = subprocess.getoutput(f'grep "(set-info :status .*)" {seed}')
            if '/sat/' in seed or 'sat' in set_status:
                oracle = 'sat'
            elif '/unsat/' in seed or 'unsat' in set_status:
                oracle = 'unsat'

        return subprocess.Popen(
            [
                'timeout',
                TIMEOUT_PER_INSTANCE,
                'bin/janus',
                '-t',
                str(SOLVER_TIMEOUT),
                '-rs',
                RULE_SET,
                '-i',
                str(ITERATIONS),
                '-wl',
                str(WALK_LENGTH),
                '-o',
                oracle,
                ';'.join(SOLVERS),
                seed,
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
        )

    def killall():
        for j in js:
            j.terminate()
        for b, r in rs:
            # Make bug eligible for reduction again by renaming the trigger file back to '.smt2'
            # When the fuzzer is restarted afterwards, the
            r.terminate()
            if os.path.exists(f"./bugs/{b}.orig"):
                os.rename(f"./bugs/{b}.orig", f"./bugs/{b}")
            if os.path.exists(f"./reducing/{b}"):
                os.remove(f"./reducing/{b}")

    def replace_finished():
        for i, j in enumerate(js):
            rc = j.poll()
            if rc is not None:
                js[i] = start_new_instance()
        for i, (f, r) in enumerate(rs):
            rc = r.poll()
            if rc is not None:
                os.rename(f"./reducing/{f}", f"./reduced/{f}")
                os.rename(f"./bugs/{f}.orig", f"./reduced/{f}.orig")
                del rs[i]
                reducible_bugs = list(
                    filter(
                        lambda f: f.endswith('.smt2')
                        and (
                            'regression-incompleteness-cvc5' in f
                            or 'regression-incompleteness-z3' in f
                        ),
                        os.listdir('bugs'),
                    )
                )
                if len(reducible_bugs) > 0:
                    bug = reducible_bugs[0]
                    solver_old, solver_new = (
                        (CVC5_OLD, CVC5_NEW)
                        if 'regression-incompleteness-cvc5' in bug
                        else (Z3_OLD, Z3_NEW)
                    )
                    rs.append((bug, start_new_reducer(solver_old, solver_new, bug)))

        reducible_bugs = list(
            filter(
                lambda f: f.endswith('.smt2')
                and (
                    'regression-incompleteness-cvc5' in f
                    or 'regression-incompleteness-z3' in f
                ),
                os.listdir('bugs'),
            )
        )

        for bug, _ in zip(reducible_bugs, range(len(rs), MAX_NUM_REDUCERS)):
            solver_old, solver_new = (
                (CVC5_OLD, CVC5_NEW)
                if 'regression-incompleteness-cvc5' in bug
                else (Z3_OLD, Z3_NEW)
            )
            rs.append((bug, start_new_reducer(solver_old, solver_new, bug)))

    def print_status():

        cvc5_regressions = 0
        cvc5_implications = 0
        cvc5_unsound = 0
        cvc5_crash = 0
        cvc5_segfault = 0
        z3_regressions = 0
        z3_implications = 0
        z3_unsound = 0
        z3_crash = 0
        z3_segfault = 0

        for f in filter(
            lambda f: f.endswith('.smt2') and not f.endswith('-previous.smt2'),
            os.listdir('bugs'),
        ):
            if 'regression-incompleteness-cvc5' in f:
                cvc5_regressions += 1
            if 'regression-incompleteness-z3' in f:
                z3_regressions += 1
            if 'implication incompleteness-cvc5' in f:
                cvc5_implications += 1
            if 'implication incompleteness-z3' in f:
                z3_implications += 1
            if 'incorrect-z3' in f:
                z3_unsound += 1
            if 'incorrect-cvc5' in f:
                cvc5_unsound += 1
            if 'crash-z3' in f:
                z3_crash += 1
            if 'crash-cvc5' in f:
                cvc5_crash += 1
            if 'segfault-z3' in f:
                z3_segfault += 1
            if 'segfault-cvc5' in f:
                cvc5_segfault += 1

        cvc5_regressions_r = 0
        cvc5_implications_r = 0
        z3_regressions_r = 0
        z3_implications_r = 0

        for f in filter(
            lambda f: f.endswith('.smt2') and not f.endswith('-previous.smt2'),
            os.listdir('reduced'),
        ):
            if 'regression-incompleteness-cvc5' in f:
                cvc5_regressions_r += 1
            if 'regression-incompleteness-z3' in f:
                z3_regressions_r += 1
            if 'implication incompleteness-cvc5' in f:
                cvc5_implications_r += 1
            if 'implication incompleteness-z3' in f:
                z3_implications_r += 1

        running_j = 0
        for j in js:
            if j.poll() is None:
                running_j += 1
        running_r = 0
        for b, r in rs:
            if r.poll() is None:
                running_r += 1

        num_processes = len(psutil.Process().children())

        status_lines = list(
            map(
                lambda l: l.ljust(OUTPUT_WIDTH),
                [
                    f"started: {start_time.strftime('%d/%m/%Y %H:%M:%S')}",
                    f"uptime: {str(datetime.datetime.now() - start_time).split('.')[0]}",
                    f"number of processes: {num_processes}",
                    f"Running instances: {running_j}/{MAX_NUM_INSTANCES}",
                    f"Running reducers: {running_r}/{MAX_NUM_REDUCERS}",
                    f"Unreduced segfaults: {z3_segfault} (z3), {cvc5_segfault} (cvc5)",
                    f"Unreduced crashes: {z3_crash} (z3), {cvc5_crash} (cvc5)",
                    f"Unreduced unsoundnesses: {z3_unsound} (z3), {cvc5_unsound} (cvc5)",
                    f"Unreduced regressions: {z3_regressions} (z3), {cvc5_regressions} (cvc5)",
                    f"Unreduced implications: {z3_implications} (z3), {cvc5_implications} (cvc5)",
                    f"Reduced regressions: {z3_regressions_r} (z3), {cvc5_regressions_r} (cvc5)",
                    f"Reduced implications: {z3_implications_r} (z3), {cvc5_implications_r} (cvc5)",
                ],
            )
        )
        status = '\n'.join(status_lines) + '\n' + ('=' * OUTPUT_WIDTH) + '\n'
        prevlines = "\033[F" * (status.count('\n') + 1)
        sys.stdout.write(prevlines + '\n' + status)
        sys.stdout.flush()

    def cleanup(signum, frame):
        signal.signal(signum, signal.SIG_IGN)
        killall()
        sys.exit(0)

    signal.signal(signal.SIGINT, cleanup)
    atexit.register(killall)

    for _ in range(MAX_NUM_INSTANCES):
        js.append(start_new_instance())

    for bug in filter(lambda f: f.endswith('.smt2'), os.listdir('bugs')):
        if len(rs) >= MAX_NUM_REDUCERS:
            break
        if 'regression-incompleteness-z3' in bug:
            rs.append((bug, start_new_reducer(Z3_OLD, Z3_NEW, bug)))
        if 'regression-incompleteness-cvc5' in bug:
            rs.append((bug, start_new_reducer(CVC5_OLD, CVC5_NEW, bug)))

    while True:
        print_status()
        replace_finished()
        time.sleep(5)

    killall()
